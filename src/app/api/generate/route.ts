import { NextRequest, NextResponse } from "next/server";
import { createRouteClient } from "@/lib/supabase/server";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

export async function POST(req: NextRequest) {
    try {
        const { supabase } = createRouteClient(req);
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

        const { materialId, type } = await req.json();

        // 1. Fetch Material details
        const material = await prisma.studyMaterial.findUnique({
            where: { id: materialId, userId: user.id }
        });

        if (!material || !material.contentUrl) {
            return NextResponse.json({ error: "Material not found" }, { status: 404 });
        }

        // 2. Call Python Microservice
        console.log(`[GENERATE] Triggering ${type} for ${material.id}`);
        const aiResponse = await fetch("http://localhost:8000/process", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                file_url: material.contentUrl,
                file_type: material.type,
                generate_type: type // summary, quiz, flashcards
            }),
        });

        if (!aiResponse.ok) {
            return NextResponse.json({ error: "AI Service failed" }, { status: 500 });
        }

        const aiResult = await aiResponse.json();
        console.log("[GENERATE] AI Result:", JSON.stringify(aiResult).substring(0, 500));

        const aiData = aiResult.ai_data;
        if (!aiData) throw new Error("No AI data returned from service");

        // 3. Persist based on type (with safety checks)
        if (type === "summary") {
            await prisma.studyMaterial.update({
                where: { id: materialId },
                data: { summary: aiData.summary || "Summary generation focused on providing key insights." }
            });
        } else if (type === "quiz") {
            const questions = aiData.quiz || [];
            if (questions.length === 0) throw new Error("AI failed to generate quiz questions");

            await prisma.quiz.create({
                data: {
                    materialId,
                    title: material.title + " - Practice Quiz",
                    questions: {
                        create: questions.map((q: any) => ({
                            question: q.question || "Question placeholder",
                            options: q.options || ["A", "B", "C", "D"],
                            correctAnswer: q.answer || q.correctAnswer || "A",
                            explanation: "Generated by AI"
                        }))
                    }
                }
            });
        } else if (type === "flashcards") {
            const cards = aiData.flashcards || [];
            if (cards.length === 0) throw new Error("AI failed to generate flashcards");

            await prisma.deck.create({
                data: {
                    materialId,
                    title: material.title + " Flashcards",
                    cards: {
                        create: cards.map((card: any) => ({
                            front: card.front || "Term",
                            back: card.back || "Description",
                            difficulty: "MEDIUM"
                        }))
                    }
                }
            });
        }

        return NextResponse.json({ success: true, data: aiData });

    } catch (error: any) {
        console.error("[GENERATE] Error Details:", error.message);
        return NextResponse.json({ error: error.message || "Internal Server Error" }, { status: 500 });
    }
}
